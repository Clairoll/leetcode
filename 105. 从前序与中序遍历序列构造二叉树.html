<!--
 * @Autor: Clairoll
 * @Date: 2021-04-01 15:27:05
 * @LastEditTime: 2021-04-01 15:47:44
 * @Email: 1755033445@qq.com
 * @description: 
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <script>
    // 根据一棵树的前序遍历与中序遍历构造二叉树。

    // 注意:
    // 你可以假设树中没有重复的元素。

    // 例如，给出

    // 前序遍历 preorder = [3,9,20,15,7]
    // 中序遍历 inorder = [9,3,15,20,7]
    // 返回如下的二叉树：

    //     3
    //    / \
    //   9  20
    //     /  \
    //    15   7


    function TreeNode(val, left, right) {
      this.val = (val === undefined ? 0 : val)
      this.left = (left === undefined ? null : left)
      this.right = (right === undefined ? null : right)
    }

    /**
     * @param {number[]} preorder
     * @param {number[]} inorder
     * @return {TreeNode}
     */
    // 有如下特征：

    // 前序中左起第一位1肯定是根结点，我们可以据此找到中序中根结点的位置rootin；
    // 中序中根结点左边就是左子树结点，右边就是右子树结点，即[左子树结点，根结点，右子树结点]，我们就可以得出左子树结点个数为int left = rootin - leftin;；
    // 前序中结点分布应该是：[根结点，左子树结点，右子树结点]；
    // 根据前一步确定的左子树个数，可以确定前序中左子树结点和右子树结点的范围；
    // 如果我们要前序遍历生成二叉树的话，下一层递归应该是：
    // 左子树：root->left = pre_order(前序左子树范围，中序左子树范围，前序序列，中序序列);；
    // 右子树：root->right = pre_order(前序右子树范围，中序右子树范围，前序序列，中序序列);。
    // 每一层递归都要返回当前根结点root；
    var buildTree = function (preorder, inorder) {

    };

    console.log(buildTree([3, 9, 20, 15, 7], [9, 3, 15, 20, 7]))
  </script>
</body>

</html>