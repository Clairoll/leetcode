<!--
 * @Autor: Clairoll
 * @Date: 2021-02-19 10:36:25
 * @LastEditTime: 2021-02-19 11:07:26
 * @Email: 1755033445@qq.com
 * @description: 
-->
<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
</body>
<script>
  // 给定一个由若干 0 和 1 组成的数组 A，我们最多可以将 K 个值从 0 变成 1 。

  // 返回仅包含 1 的最长（连续）子数组的长度。

  // 示例 1：

  // 输入：A = [1,1,1,0,0,0,1,1,1,1,0], K = 2
  // 输出：6
  // 解释： 
  // [1,1,1,0,0,1,1,1,1,1,1]
  // 粗体数字从 0 翻转到 1，最长的子数组长度为 6。
  // 示例 2：

  // 输入：A = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3
  // 输出：10
  // 解释：
  // [0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]
  // 粗体数字从 0 翻转到 1，最长的子数组长度为 10。

  // 提示：

  // 1 <= A.length <= 20000
  // 0 <= K <= A.length
  // A[i] 为 0 或 1 
  /**
   * @param {number[]} A
   * @param {number} K
   * @return {number}
   */
  var longestOnes = function (A, K) {
    let left = 0, right = 0, res = 0, zero = 0;

    while (right < A.length) {
      if (A[right] == 0) {
        zero++
      }
      while (zero > K) { // 超出替换个数
        if (A[left] == 0) {
          zero--
        }
        left++ // 左移
      }
      right++ // 右移
      if (right - left > res) { // 更新数据
        res = right - left
      }
    }
    return res
  };

  console.log(longestOnes([0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 1, 1, 1, 1], 3))
</script>
</body>

</html>